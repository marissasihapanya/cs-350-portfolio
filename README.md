<b>Morse Code Project</b>
The aim of the first project was to make a device that communicates in morse code, which then changes messages when a button is pressed. The message does not change until the current message is complete. Red LED indicated dot, and green LED indicated dash.
The main stipulation was that the period of the timer was 500ms. A dash turned on the green LED for 1500ms, so figuring out how to make the system light the green LED for that period of time when limited to just 500ms each was a challenge. What I did really well was structuring the pseudocode after understanding the core problem. Each letter had different combinations of dashes and dots, and we had to translate that to the 500ms timings. On top of that, we also had to account for gaps between dots, dashes, characters, words, and messages. I understood the problem thoroughly so it allowed me to tackle the project with confidence. However, understanding the key part of using the 500ms to my advantage to emulate morse code only realized near the end of the project. That is where I got particularly stuck. I first emulated time by creating a count variable, incrementing it, then turning on the LEDs for 500ms or 1500ms by wrapping them inside a slew of if statements. I had one state machine with states SOS and OK, and no identifiers for dot, dash, and gap. This was not the kind of behavior that would be optimal for the project, so at the end I devised I could use two state machines to my advantage. Now that I had individual states fot dot, dash, and gap, implementing the 500ms pieces became much easier. I built a char sequence for each message (SOS and OK) and sequentially built the messages based on the characters with corresponding dots and dashes. This allowed me to build a dash properly, having the green LED light for 1500ms by writing the dash state 3 times in a sequence. I repeated this logic for every character to construct the words in each message. One particular tool I'll continue sharpening from this project is the tool of critical thinking. Charging in headfirst is not always the best approach, but slowing down and thinking through the issue, really combing through all the requirements, will allow for the solution to any problem. This also transfers to a personable skill that I will use in my future developments. This project is particularly maintainable, readable, and adaptable because of the two state machines with distinct, intuitive states that drive the main functionality of the morse code project.


<br>
<b>Thermostat Project</b>
The aim of the project was to make a thermostat from the TI CC3220S XL Launchpad, using various interfaces we have built on throughout the course.
The thermostat needed to sense the temperature of the room then output the temperature to the console. Moreover, the thermostat needed to turn on a red LED to indicate that the heat was on. The heat mechanic was configured with setting a setpoint, which was changed by pressing the buttons on the side of the device. The project solved this thermostat problem by interweaving GPIO, I2C, UART, and timers, and interrupts.
For this project, I excelled in my persistence. The first day I sat down with the project and the starter code, it all ran with errors and did not output anything. However, I sat for hours at a time troubleshooting the reason why those errors persisted, and was determined to see what was wrong. I finally figured that the display macro and its succeeding calls were configured incorrectly, causing no .out file to generate when the code built. There were many times in this project where I felt stumped, but my determination kept me going and drove me to the end with a full implementation.
I could definitely improve with trusting myself more. Reading the code more and devising solutions on my own. I referenced documentation a lot and searched the web for answers, but I definitely want to sharpen my own mind and self reliance, so I can problem solve on my own. I see the value in referring to your resources, but I want to hold that type of independence.
The kind of tool/resource I'll add to my support network is technical documentation. There was a plethora of that for this device, so for both software and hardware development I do in the future, I will reference technical documentation thoroughly.
The skills that I can transfer to future projects are pieces I've mentioned previously here. Determination, self-trust, research, and curiosity are all skills I will continuously strengthen throughout my career; they will serve me well.
What allowed me to make this project maintainable, readable, and adaptable: the development of my own functions to check the buttons and check the temperature. Then, using those functions in the main code to drive the functionality of the thermostat. Being able to produce your own reusable functions is a core piece of many applications.
This project allowed me to grow in many ways as a developer, and I am glad I stuck through to the end. I am extremely proud of the end result, and will keep it around as a reminder of what I can achieve.
